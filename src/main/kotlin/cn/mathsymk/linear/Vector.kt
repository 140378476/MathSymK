package cn.mathsymk.linear

import cn.mathsymk.ValueEquatable
import cn.mathsymk.ModeledMathObject
import cn.mathsymk.model.struct.VectorModel
import cn.mathsymk.structure.*
import java.util.function.Function


/**
 * Describes a vector
 *
 * By default, all the vectors are treated as column vectors.
 *
 * @author Ezrnest
 */
interface Vector<T> : GenVector<T>, ModeledMathObject<T, EqualPredicate<T>>, VectorModel<T, Vector<T>> {
    /*
    Created by Ezrnest at 2024/09/04 15:33
     */

    override fun applyAll(f: (T) -> T): Vector<T> {
        return VectorImpl.apply1(this, model, f)
    }

    override fun valueEquals(obj: ValueEquatable<T>): Boolean {
        if (obj !is Vector) return false
        if (size != obj.size) return false
        return indices.all { model.isEqual(this[it], obj[it]) }
    }

    override fun <N> mapTo(newModel: EqualPredicate<N>, mapping: Function<T, N>): Vector<N> {
        return VectorImpl.apply1(this, newModel, mapping::apply)
    }


    override val isZero: Boolean
        get() {
            val model = model as AddGroup<T>
            return indices.all { model.isZero(this[it]) }
        }

    override fun plus(y: Vector<T>): Vector<T> {
        return VectorImpl.add(this, y, model as AddSemigroup<T>)
    }

    override fun unaryMinus(): Vector<T> {
        return VectorImpl.negate(this, model as AddGroup<T>)
    }

    override fun scalarMul(k: T): Vector<T> {
        return VectorImpl.multiply(this, k, model as MulSemigroup<T>)
    }


    override fun scalarDiv(k: T): Vector<T> {
        return VectorImpl.divide(this, k, model as MulGroup<T>)
    }

    override fun minus(y: Vector<T>): Vector<T> {
        return VectorImpl.subtract(this, y, model as AddGroup<T>)
    }

    override fun timesLong(n: Long): Vector<T> {
        return VectorImpl.multiplyLong(this, n, model as AddGroup<T>)
    }

    /**
     * Returns the inner (dot) product of this vector and the given vector: `⟨this, v⟩`.
     * The result is a scalar.
     */
    infix fun inner(v: Vector<T>): T {
        return VectorImpl.inner(this, v, model as Ring<T>)
    }

    /**
     * Returns the element-wise (Hadamard) product of this vector and the given vector: `this ⊙ v`.
     * The result is a new vector with the same size as this vector.
     *
     */
    infix fun odot(v: Vector<T>): Vector<T> {
        return VectorImpl.odot(this, v, model as MulSemigroup<T>)
    }

    /**
     * Returns the Euclidean norm of this vector, which is the square root of the sum of squares of all elements.
     */
    fun norm(): T {
        return VectorImpl.norm(this, model as Reals<T>)
    }

    /**
     * Returns the sum of squares of all elements, which is the square of the norm.
     */
    fun normSq(): T {
        return VectorImpl.normSq(this, model as Ring<T>)
    }

//    fun normP()

    fun unitize(): Vector<T> {
        return VectorImpl.unitize(this, model as Reals<T>)
    }


    companion object {

        /**
         * Creates a new vector with the given [size] and [model], and the data is generated by the [init].
         *
         * The [init] function will be called with the index of the element, and the return value will be the value of the element.
         *
         * @param size the size of the vector
         * @param model the model of the vector
         */
        operator fun <T> invoke(size: Int, model: EqualPredicate<T>, init: (Int) -> T): MutableVector<T> {
            require(size > 0)
            return AVector.of(size, model, init)
        }

        /**
         * Creates a new vector from a list of [data] and the given [model].
         */
        fun <T> of(data: List<T>, model: EqualPredicate<T>): MutableVector<T> {
            return AVector(data.size, model) { k -> data[k] }
        }

        /**
         * Creates a new vector with the given [model] and [data].
         */
        fun <T> of(model: EqualPredicate<T>, vararg data: T): MutableVector<T> {
            return of(data.asList(), model)
        }

        fun <T> of(model: EqualPredicate<T>, data: GenVector<T>): MutableVector<T> {
            return of(data.toList(), model)
        }

        fun <T> zero(size: Int, model: AddMonoid<T>): MutableVector<T> {
            return VectorImpl.zero(size, model)
        }

        fun <T> constant(size: Int, value: T, model: EqualPredicate<T>): MutableVector<T> {
            return VectorImpl.constant(size, value, model)
        }

        fun <T> sum(vs: List<Vector<T>>): Vector<T> {
            require(vs.isNotEmpty())
            val size = vs[0].size
            val model = vs[0].model as AddMonoid<T>
            return VectorImpl.sum(vs, size, model)
        }

        fun <T> sum(vararg vs: Vector<T>): Vector<T> {
            return sum(vs.asList())
        }

        /**
         * Gets a unit vector with the given [length] with the [index] element being `1` and all other elements being `0`.
         */
        fun <T> unitVector(length: Int, index: Int, model: UnitRing<T>): Vector<T> {
            require(index in 0..<length)
            return zero(length, model).also { it[index] = model.one }
        }


        fun <T> space(field: Field<T>, length: Int): CanonicalVectorSpace<T> {
            return CanonicalVectorSpace(length, field)
        }


    }
}

/**
 * A wrapper class for a row vector.
 */
@JvmRecord
data class RowVector<T>(val v: Vector<T>) : GenVector<T> {
    override val size: Int
        get() = v.size

    override fun elementSequence(): Sequence<T> {
        return v.elementSequence()
    }

    override fun get(i: Int): T {
        return v[i]
    }

    override fun toList(): List<T> {
        return v.toList()
    }

    override fun applyAll(f: (T) -> T): RowVector<T> {
        return RowVector(v.applyAll(f))
    }
}

/**
 * Returns a row vector view of this vector.
 *
 * This method enables writing codes such as `v.T * A * v`, where `A` is a matrix.
 */
val <T> Vector<T>.T: RowVector<T> get() = RowVector(this)

fun <T> RowVector<T>.matmul(v: Vector<T>): T {
    return this.v inner v
}

operator fun <T> RowVector<T>.times(v: Vector<T>): T {
    return this.matmul(v)
}


interface MutableVector<T> : Vector<T> {
    operator fun set(i: Int, value: T)

    fun copy(): MutableVector<T> {
        return VectorImpl.copyOf(this)
    }

    operator fun plusAssign(y: Vector<T>) {
        val model = model as AddSemigroup<T>
        for (i in indices) {
            this[i] = model.add(this[i], y[i])
        }
    }

    operator fun minusAssign(y: Vector<T>) {
        val model = model as AddGroup<T>
        for (i in indices) {
            this[i] = model.subtract(this[i], y[i])
        }
    }

    operator fun timesAssign(k: T) {
        val model = model as MulSemigroup<T>
        for (i in indices) {
            this[i] = model.multiply(this[i], k)
        }
    }

    operator fun divAssign(k: T) {
        val model = model as MulGroup<T>
        for (i in indices) {
            this[i] = model.divide(this[i], k)
        }
    }

    /**
     * Performs `x += k * y` in place.
     */
    fun plusAssignTimes(k: T, y: Vector<T>) {
        val model = model as Ring<T>
        val x = this
        for (i in indices) {
            x[i] = model.eval { x[i] + k * y[i] }
        }
    }

    /**
     * Performs `x -= k * y` in place.
     */
    fun minusAssignTimes(k: T, y: Vector<T>) {
        val model = model as Ring<T>
        val x = this
        for (i in indices) {
            x[i] = model.eval { x[i] - k * y[i] }
        }
    }


}

inline fun <T> MutableVector<T>.transform(f: (T) -> T) {
    for (i in indices) {
        this[i] = f(this[i])
    }
}

data class AVector<T> internal constructor(
    val data: Array<Any?>, override val model: EqualPredicate<T>
) : MutableVector<T> {
    init {
        require(data.isNotEmpty())
    }

    override val size: Int
        get() = data.size

    override fun get(i: Int): T {
        @Suppress("UNCHECKED_CAST")
        return data[i] as T
    }

    override fun set(i: Int, value: T) {
        data[i] = value
    }

    @Suppress("UNCHECKED_CAST")
    override fun toList(): List<T> {
        return data.map { it as T }
    }

    @Suppress("UNCHECKED_CAST")
    override fun elementSequence(): Sequence<T> {
        return data.asSequence().map { it as T }
    }


    override fun copy(): AVector<T> {
        return AVector(data.copyOf(), model)
    }

    override fun toString(): String {
        return data.joinToString(prefix = "[", postfix = "]")
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as AVector<*>

        if (!data.contentEquals(other.data)) return false
        if (model != other.model) return false

        return true
    }

    override fun hashCode(): Int {
        var result = data.contentHashCode()
        result = 31 * result + model.hashCode()
        return result
    }

    companion object {

        internal inline operator fun <T> invoke(size: Int, model: EqualPredicate<T>, init: (Int) -> T): AVector<T> {
            val data = Array<Any?>(size) { k -> init(k) }
            return AVector(data, model)
        }

        fun <T> of(size: Int, model: EqualPredicate<T>, init: (Int) -> T): AVector<T> {
            return AVector(size, model, init)
        }
    }
}

object VectorImpl {

    private inline fun <T> apply2(
        x: GenVector<T>, y: GenVector<T>,
        model: EqualPredicate<T>, f: (T, T) -> T
    ): AVector<T> {
        require(x.isSameSize(y))
        return AVector(x.size, model) { k -> f(x[k], y[k]) }
    }

    internal inline fun <T, N> apply1(x: GenVector<T>, model: EqualPredicate<N>, f: (T) -> N): AVector<N> {
        return AVector(x.size, model) { k -> f(x[k]) }
    }

    fun <T> copyOf(x: Vector<T>): AVector<T> {
        return copyOf(x, x.model)
    }

    fun <T> copyOf(x: GenVector<T>, model: EqualPredicate<T>): AVector<T> {
        return apply1(x, model) { it }
    }

    fun <T> constant(size: Int, value: T, model: EqualPredicate<T>): AVector<T> {
        return AVector(size, model) { value }
    }

    fun <T> zero(size: Int, model: AddMonoid<T>): AVector<T> {
        return constant(size, model.zero, model)
    }

    fun <T> isEqual(x: GenVector<T>, y: GenVector<T>, model: EqualPredicate<T>): Boolean {
        require(x.isSameSize(y))
        return x.indices.all { model.isEqual(x[it], y[it]) }
    }

    fun <T> add(x: GenVector<T>, y: GenVector<T>, model: AddSemigroup<T>): AVector<T> {
        return apply2(x, y, model, model::add)
    }

    fun <T> subtract(x: GenVector<T>, y: GenVector<T>, model: AddGroup<T>): AVector<T> {
        return apply2(x, y, model, model::subtract)
    }

    fun <T> negate(x: GenVector<T>, model: AddGroup<T>): AVector<T> {
        return apply1(x, model, model::negate)
    }

    fun <T> multiply(x: GenVector<T>, k: T, model: MulSemigroup<T>): AVector<T> {
        return apply1(x, model) { model.multiply(k, it) }
    }

    fun <T> multiplyLong(x: GenVector<T>, k: Long, model: AddGroup<T>): AVector<T> {
        return apply1(x, model) { model.multiplyLong(it, k) }
    }

    fun <T> divide(x: GenVector<T>, k: T, model: MulGroup<T>): AVector<T> {
        return apply1(x, model) { model.divide(it, k) }
    }

    fun <T> sum(vs: List<GenVector<T>>, size: Int, cal: AddMonoid<T>): AVector<T> {
        require(vs.all { it.size == size }) { "Size mismatch! " }
        return vs.fold(zero(size, cal)) { acc, v -> add(acc, v, cal) }
    }

    fun <T> inner(x: GenVector<T>, y: GenVector<T>, model: Ring<T>): T {
        require(x.isSameSize(y))
        return x.indices.fold(model.zero) { acc, i -> model.eval { acc + x[i] * y[i] } }
    }

    fun <T> odot(x: GenVector<T>, y: GenVector<T>, model: MulSemigroup<T>): AVector<T> {
        require(x.isSameSize(y))
        return apply2(x, y, model, model::multiply)
    }


    fun <T> normSq(x: GenVector<T>, model: Ring<T>): T {
        return inner(x, x, model)
    }

    fun <T> norm(x: GenVector<T>, model: Reals<T>): T {
        return model.sqrt(normSq(x, model))
    }

    fun <T> unitize(x: GenVector<T>, model: Reals<T>): AVector<T> {
        val n = norm(x, model)
        return apply1(x, model) { model.divide(it, n) }
    }
}

open class CanonicalVectorSpace<K>(override val vectorLength: Int, override val scalars: Field<K>) :
    VectorSpace<K>, InnerProductSpace<K, Vector<K>> {

    /**
     * Creates a new vector with the given [data].
     */
    fun vec(vararg data: K): Vector<K> {
        require(data.size == vectorLength)
        return Vector.of(data.asList(), scalars)
    }


    override fun contains(x: Vector<K>): Boolean {
        return x.model == scalars && x.size == vectorLength && x.elementSequence().all { scalars.contains(it) }
    }

    override fun isEqual(x: Vector<K>, y: Vector<K>): Boolean {
        return VectorImpl.isEqual(x, y, scalars)
    }

    override val zero: Vector<K>
        get() = VectorImpl.zero(vectorLength, scalars)

    override fun negate(x: Vector<K>): Vector<K> {
        return VectorImpl.negate(x, scalars)
    }

    override fun scalarMul(k: K, v: Vector<K>): Vector<K> {
        return VectorImpl.multiply(v, k, scalars)
    }

    override fun add(x: Vector<K>, y: Vector<K>): Vector<K> {
        return VectorImpl.add(x, y, scalars)
    }

    override fun subtract(x: Vector<K>, y: Vector<K>): Vector<K> {
        return VectorImpl.subtract(x, y, scalars)
    }

    override fun sum(elements: List<Vector<K>>): Vector<K> {
        return VectorImpl.sum(elements, vectorLength, scalars)
    }

    override fun inner(u: Vector<K>, v: Vector<K>): K {
        return VectorImpl.inner(u, v, scalars)
    }


    override val basis: VectorBasis<K>
        get() = StandardVectorBasis(vectorLength, scalars)


    override fun coefficients(v: Vector<K>): List<K> {
        return v.toList()
    }
}

/**
 * A standard basis for a vector space, which is the set of unit vectors.
 */
class StandardVectorBasis<K>(
    override val vectorLength: Int,
    private val scalars: Field<K>
) : VectorBasis<K> {
    override val elements: List<Vector<K>>
        get() = (0 until vectorLength).map { i -> Vector.unitVector(vectorLength, i, scalars) }

    override fun reduce(v: Vector<K>): List<K> {
        return v.toList()
    }

    override fun produce(coefficients: List<K>): Vector<K> {
        return Vector.of(coefficients, scalars)
    }

    override fun contains(v: Vector<K>): Boolean {
        return v.model == scalars && v.size == vectorLength
    }
}